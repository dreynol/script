#!/bin/bash
# TODO:
#  delete all instances at cleanup and depend upon the results bucket?

# function to call on normal exit and on any failure
ob_cleanup()
{
	echo "remember to clean up test instances"
	exit
}

OB_REGION="us-east1"
# Must use us-central1-a zone for any vCPU count over 24
OB_ZONE="us-east1-b"
OB_PROJECT="orangefsdev"
gcloud config set compute/region "$OB_REGION"
gcloud config set compute/zone "$OB_ZONE"
gcloud config set project "$OB_PROJECT"

#OB_MPI_TYPE="intel"
#OB_MPI_TYPE="openmpi"
OB_MPI_TYPE="vanilla"

# "slots=N" affects the number of processors to use per client
OB_SLOTS=0
#OB_SLOTS=1

# affects memory usage on the ofs servers... default is 512MB
OB_DBMAXSIZE=536870912

# If set, we'll run io500 after everything is set up, else just exit. 
OB_RUN_IO500=0

# destination location for io500 config files
OB_IO500_CONFIG="/var/tmp"

#OB_IMAGE=" --image hubcap-fc34-guestenv-gvnic-io500"
#OB_IMAGE=" --image hubcap-fc34-guestenv-gvnic-io500-2"
#OB_IMAGE=" --image hubcap-fc34-guestenv-gvnic-io500-3"
OB_IMAGE=" --image hubcap-io500-oiv1"

OB_SCOPE=" --scopes=cloud-platform"

# persistant place for results and configs and whatever.
OB_BUCKET="gs://hubcap_bucket"

OB_OFS_NAME="pattern-ofs-"
OB_IO500_NAME="pattern-io500-"

# total number of servers and clients to create
OB_OFS_SERVERS=1
OB_OFS_PORT=3334
OB_OFS_PER_INSTANCE=4
OB_SEPARATE_DATA_META=1
OB_OFS_MACHINE=" --machine-type=n1-standard-1"
#OB_OFS_MACHINE=" --machine-type=n2-standard-80"

OB_IO500_CLIENTS=0
OB_IO500_MACHINE=" --machine-type=n1-standard-1"
#OB_IO500_MACHINE=" --machine-type=n1-standard-16"

# MAX per instance: 24 local SSD partitions - 9 TB - 2.4 million read IOPS
# My observation is that nvme device names will be /dev/nvme0n1 - /dev/nvme0n24
# valid number of ssd drives per instance: [0, 1, 2, 3, 4, 5, 6, 7, 8, 16, 24]
OB_SSD_NUM=8
OB_SSD_ARG=" --local-ssd interface=nvme"
OB_SSD_DEV="/dev/nvme0n"
OB_MDADM="mdadm --create /dev/md0 --level=0 --raid-devices="
OB_MOUNT_POINT="/var/lib/orangefs"

OB_NET_INT=""
#OB_NET_INT=" --network-interface=nic-type=GVNIC"
OB_NET_PERF=""
#OB_NET_PERF=" --network-performance-configs=total-egress-bandwidth-tier=TIER_1"


# Here we can configure some servers to be data only, some to be meta only,
# and the rest will be both.
OB_OFS_DATA=1		# number of ofs data-only servers 
OB_OFS_META=1		# number of ofs meta-only servers

OB_OFS_CONFIG="pvfs2-genconfig --iospec "
OB_OFS_CONFIG_FILE_NAME="orangefs.conf"
# clean up any leftover old config files or hostfiles from previous runs.
rm -f "$OB_OFS_CONFIG_FILE_NAME"
rm -f hostfile
rm -f pub.keys

# After starting the instances we'll test their ssh ports this
# many times before we give up and exit.
OB_ATTEMPTS=5

# seconds to sleep between attempts
OB_SLEEP=5

OB_CREATE="gcloud compute instances create "

if [ $(( OB_OFS_DATA + OB_OFS_META )) -gt \
	$(( OB_OFS_SERVERS * OB_OFS_PER_INSTANCE )) ]
then
	echo "sum of pure data + pure meta must not exceed pvfs2-server number."
	ob_cleanup
fi

# create array of port numbers, one for each server.
current_port="$OB_OFS_PORT"
for i in `seq $OB_OFS_PER_INSTANCE`
do
	port[i]="$current_port"
	current_port=$(( current_port + 1 ))
done

if [ "$OB_SSD_NUM" -lt "1" ]
then
	echo "must have at least one SSD."
	ob_cleanup
fi

if [ "$OB_SSD_NUM" -lt "$OB_OFS_PER_INSTANCE" ]
then
	echo "need at least one SSD for each pvfs2-server process."
	echo "OB_SSD_NUM:""$OB_SSD_NUM"":"
	echo "OB_OFS_PER_INSTANCE:""$OB_OFS_PER_INSTANCE"":"
	ob_cleanup
fi

if [ "$OB_SSD_NUM" -lt $(( OB_OFS_PER_INSTANCE * 2 )) -a \
	"$OB_SEPARATE_DATA_META" -eq "1" ]
then
	echo "need at least two SSDs per pvfs2-server process to"
	echo "keep IO and metadata separate."
	ob_cleanup
fi

# indexed array of alphabet letters to append to host names for differentiation
OB_ALPHA=( {0,{a..z},{A..Z}} )
OB_MAX=52

# create arrays of data and meta servers and use them to build
# a pvfs2-genconfig command, which will end up looking something like this:
# pvfs2-genconfig --iospec one:3334,two:3334,three:3334,four:3334 \
#  --metaspec one:3334,two:3334 --quiet pvfs.conf
for i in `seq 1 $OB_OFS_SERVERS`
do
	for j in `seq 1 $OB_OFS_PER_INSTANCE`
	do
		if [ "$OB_OFS_DATA" -gt "0" ]
		then
			OB_DATA_ARRAY+=($OB_OFS_NAME${OB_ALPHA[i]}:${port[$j]})
			OB_OFS_DATA=$(( OB_OFS_DATA - 1 ))
		elif [ "$OB_OFS_META" -gt "0" ]
		then
			OB_META_ARRAY+=($OB_OFS_NAME${OB_ALPHA[i]}:${port[$j]})
			OB_OFS_META=$(( OB_OFS_META - 1 ))
		else
			OB_DATA_ARRAY+=($OB_OFS_NAME${OB_ALPHA[i]}:${port[$j]})
			OB_META_ARRAY+=($OB_OFS_NAME${OB_ALPHA[i]}:${port[$j]})
		fi
	done
done

# add the list of data servers to the pvfs2-genconfig command
for i in "${OB_DATA_ARRAY[@]}"
do
	OB_OFS_CONFIG="$OB_OFS_CONFIG"`echo -n $i`","
done
# chop off the trailing comma and get ready for the meta list
OB_OFS_CONFIG=`echo ${OB_OFS_CONFIG%?}`" --metaspec "
for i in "${OB_META_ARRAY[@]}"
do
	OB_OFS_CONFIG="$OB_OFS_CONFIG"`echo -n $i`","
done
# chop off the trailing comma and finish building the command
OB_OFS_CONFIG=`echo ${OB_OFS_CONFIG%?}`" --filesystem-dbmaxsize ""$OB_DBMAXSIZE"
OB_OFS_CONFIG="$OB_OFS_CONFIG"" --quiet ""$OB_OFS_CONFIG_FILE_NAME"
echo ":""$OB_OFS_CONFIG"":"

eval "$OB_OFS_CONFIG"
# simplify the autogened config file...
#sed -i -n '/ServerOptions/q;p' "$OB_OFS_CONFIG_FILE_NAME"
#sed -i 's/_tcp....//g' "$OB_OFS_CONFIG_FILE_NAME"

# associative array for host names to ip addrs
declare -A OB_EX_ETC_HOSTS # external addrs
declare -A OB_IN_ETC_HOSTS # internal addrs

# create the ofs servers and collect their external and internal IP addrs
for i in `seq 1 $OB_OFS_SERVERS`
do
	OB_CMD="$OB_CREATE""$OB_OFS_NAME""${OB_ALPHA[i]}"
	OB_CMD="$OB_CMD""$OB_IMAGE""$OB_OFS_MACHINE""$OB_SCOPE"
	OB_CMD="$OB_CMD""$OB_NET_INT""$OB_NET_PERF"
	for j in `seq 1 $OB_SSD_NUM`
	do
		OB_CMD="$OB_CMD""$OB_SSD_ARG"
	done
#	echo $OB_CMD
#	exit
	eval $OB_CMD
	if [ "$?" -gt "0" ]
	then
		echo "creation of ""$OB_OFS_NAME""${OB_ALPHA[i]}"" failed."
		ob_cleanup
	fi
	OB_EX_ETC_HOSTS["$OB_OFS_NAME""${OB_ALPHA[i]}"]=`gcloud compute instances describe "$OB_OFS_NAME""${OB_ALPHA[i]}" --format='get(networkInterfaces[0].accessConfigs[0].natIP)'`
	if [ "$?" -gt "0" ]
	then
		echo "no external ip for ""$OB_OFS_NAME""${OB_ALPHA[i]}""."
		ob_cleanup
	fi
	OB_IN_ETC_HOSTS["$OB_OFS_NAME""${OB_ALPHA[i]}"]=`gcloud compute instances describe "$OB_OFS_NAME""${OB_ALPHA[i]}" --format='get(networkInterfaces[0].networkIP)'`
	if [ "$?" -gt "0" ]
	then
		echo "no internal ip for ""$OB_OFS_NAME""${OB_ALPHA[i]}""."
		ob_cleanup
	fi
done

echo ""

# create the io500 servers and collect their external and internal IP addrs
for i in `seq 1 $OB_IO500_CLIENTS`
do
	OB_CMD="$OB_CREATE""$OB_IO500_NAME""${OB_ALPHA[i]}"
	OB_CMD="$OB_CMD""$OB_IMAGE""$OB_IO500_MACHINE""$OB_SCOPE"
	OB_CMD="$OB_CMD""$OB_NET_INT""$OB_NET_PERF"
#	echo $OB_CMD
	eval $OB_CMD
	OB_EX_ETC_HOSTS["$OB_IO500_NAME""${OB_ALPHA[i]}"]=`gcloud compute instances describe "$OB_IO500_NAME""${OB_ALPHA[i]}" --format='get(networkInterfaces[0].accessConfigs[0].natIP)'`
	OB_IN_ETC_HOSTS["$OB_IO500_NAME""${OB_ALPHA[i]}"]=`gcloud compute instances describe "$OB_IO500_NAME""${OB_ALPHA[i]}" --format='get(networkInterfaces[0].networkIP)'`
done

# Don't continue if unable to connect to ssh port in the allotted time.
echo -n "Testing connectivity to port 22 on orangefs servers. "
for i in `seq 1 $OB_OFS_SERVERS`
do
	OB_TRYS=$OB_ATTEMPTS
	while [ "$OB_TRYS" -gt "0" ] && \
		! nc -z ${OB_EX_ETC_HOSTS["$OB_OFS_NAME""${OB_ALPHA[i]}"]} 22
	do
		sleep $OB_SLEEP
		OB_TRYS=$(( OB_TRYS - 1 ))
		if [ "$OB_TRYS" -eq "0" ]
		then
			echo -e "\nno response from " \
			"${OB_EX_ETC_HOSTS["$OB_OFS_NAME""${OB_ALPHA[i]}"]}" \
			"on port 22."
			ob_cleanup
		fi
	done
	echo -n "."
done
echo " done."

echo -n "add ofs server internal IP addrs to each servers's host file. "
# make a local file of host lines to add to all the cloud servers.
for i in `seq 1 $OB_OFS_SERVERS`
do
	OB_IN_IP="${OB_IN_ETC_HOSTS["$OB_OFS_NAME""${OB_ALPHA[i]}"]}"
	OB_HOST="$OB_OFS_NAME""${OB_ALPHA[i]}"
	echo "$OB_IN_IP"" ""$OB_HOST" >> hostfile
done
# append the local host file onto the end of all the server /etc/host files.
for i in `seq 1 $OB_OFS_SERVERS`
do
	OB_EX_IP="${OB_EX_ETC_HOSTS["$OB_OFS_NAME""${OB_ALPHA[i]}"]}"
	OB_HOST="$OB_OFS_NAME""${OB_ALPHA[i]}"
	# As we run tests over and over, IP addresses will end up
	# getting reused. We want to run tests without having to
	# do a bunch of .ssh/known_hosts maintenance, we'll turn
	# off host key checking and fling the WARNING message to dev null.
	scp -o "StrictHostKeyChecking no" \
		hostfile "$OB_EX_IP": > /dev/null 2>&1
	if [ "$?" -gt "0" ]
	then
		echo -e "\nscp host file to :"$OB_HOST": failed."
		ob_cleanup
	fi
	ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
		sudo sh -c \'cat hostfile \>\> /etc/hosts\' > /dev/null 2>&1
	if [ "$?" -gt "0" ]
	then
		echo -e "\nappend hostfile on :"$OB_HOST": failed."
		ob_cleanup
	fi
	echo -n "."
done
echo " done."

# One SSD per pvfs2-server process or two SSDs per process if separate
# IO and metadata.
if [ $(( OB_SSD_NUM / OB_OFS_PER_INSTANCE )) -eq "1" ] ||
	[ $(( OB_SSD_NUM / OB_OFS_PER_INSTANCE )) -eq "2" -a \
		"$OB_SEPARATE_DATA_META" -eq "1" ]
then
	for i in `seq 1 $OB_OFS_SERVERS`
	do
		OB_EX_IP="${OB_EX_ETC_HOSTS["$OB_OFS_NAME""${OB_ALPHA[i]}"]}"
		OB_HOST="$OB_OFS_NAME""${OB_ALPHA[i]}"
		for j in `seq 1 $OB_SSD_NUM`
		do
			OB_LABEL="parted /dev/nvme0n"$j" --script mklabel gpt"
			ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
				sudo sh -c \'"$OB_LABEL"\' > /dev/null 2>&1
			if [ "$?" -gt "0" ]
			then
				echo "labeling failed "$OB_HOST" "$j
				ob_cleanup
			fi

			OB_PARTITION="parted -a optimal /dev/nvme0n"$j
			OB_PARTITION=$OB_PARTITION" --script mkpart"
			OB_PARTITION=$OB_PARTITION" primary ext4 2048 375GB"
			
			ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
				sudo sh -c \'"$OB_PARTITION"\' > /dev/null 2>&1
			if [ "$?" -gt "0" ]
			then
				echo "Partitioning failed "$OB_HOST" "$j
				ob_cleanup
			fi

			OB_MKFS="mkfs.ext4 -F /dev/nvme0n"$j"p1"
			ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
				sudo sh -c \'"$OB_MKFS"\' > /dev/null 2>&1
			if [ "$?" -gt "0" ]
			then
				echo "mkfs failed "$OB_HOST" "$j
				ob_cleanup
			fi

			if [ "$OB_SEPARATE_DATA_META" -eq "1" ]
			then
				if [ $(( j % 2 )) -eq 0 ]
				then
					index=$(( j / 2 ))
					mount_point="$OB_MOUNT_POINT""${port[$index]}"
					mount_point="$mount_point""/meta"
				else
					index=$((( j + 1) / 2 ))
					mount_point="$OB_MOUNT_POINT""${port[$index]}"
					mount_point="$mount_point""/data"
				fi
			else
				mount_point="$OB_MOUNT_POINT""${port[$j]}"
			fi
			ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
			sudo sh -c \'mkdir -m 777 -p "$mount_point"\' \
					> /dev/null 2>&1
			if [ "$?" -gt "0" ]
			then
				echo "mkdir mount point "$OB_HOST" "$j
				ob_cleanup
			fi

			OB_MOUNT="mount /dev/nvme0n"$j"p1 ""$mount_point"
			ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
				sudo sh -c \'"$OB_MOUNT"\' > /dev/null 2>&1
			if [ "$?" -gt "0" ]
			then
				echo "mount failed "$OB_HOST" "$j
				ob_cleanup
			fi
			echo "SSD #"$j" mounted on "$OB_HOST
		done
	done
else
	# More than one SSD per orangefs server.
	for i in `seq 1 $OB_OFS_SERVERS`
	do
		OB_EX_IP="${OB_EX_ETC_HOSTS["$OB_OFS_NAME""${OB_ALPHA[i]}"]}"
		OB_HOST="$OB_OFS_NAME""${OB_ALPHA[i]}"

		ssd_per_ofs=$(( OB_SSD_NUM / OB_OFS_PER_INSTANCE))
		ssd_start=1
		ssd_end=$ssd_per_ofs
		for j in `seq 1 $OB_OFS_PER_INSTANCE`
		do

			echo "mount md"$j" on "$OB_HOST
			OB_MDADM="mdadm --create /dev/md"$j
			OB_MDADM="$OB_MDADM"" --level=0 --raid-devices="
			OB_MDADM="$OB_MDADM""$ssd_per_ofs"

			for k in `seq $ssd_start $ssd_end`
			do
				OB_MDADM="$OB_MDADM"" $OB_SSD_DEV""$k"
			done
			ssd_start=$(( ssd_start + ssd_per_ofs ))
			ssd_end=$(( ssd_end + ssd_per_ofs ))
			ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
				sudo sh -c \'"$OB_MDADM"\' > /dev/null 2>&1
			if [ "$?" -gt "0" ]
			then
				echo "mdadm failed for "$OB_HOST" "$ssd_start
				ob_cleanup
			fi

			ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" sudo \
				sh -c \'mkfs.ext4 -F /dev/md"$j"\' \
					> /dev/null 2>&1
			if [ "$?" -gt "0" ]
			then
				echo "mkfs failed for "$OB_HOST" "$j
				ob_cleanup
			fi

			mount_point="$OB_MOUNT_POINT""${port[$j]}"
			ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
				sudo sh -c \'mkdir "$mount_point"\' \
					> /dev/null 2>&1
			if [ "$?" -gt "0" ]
			then
				echo "mkdir mount point "$OB_HOST" "$j
				ob_cleanup
			fi

			ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" sudo \
				sh -c \'mount /dev/md"$j" \
					 "$mount_point"\' > /dev/null 2>&1
			if [ "$?" -gt "0" ]
			then
				echo "mount failed "$OB_HOST" "$j
				ob_cleanup
			fi
			echo "RAID mounted on "$OB_HOST" "$j
		done
	done
fi

echo -n "start ofs servers. "
for i in `seq 1 $OB_OFS_SERVERS`
do
	OB_EX_IP="${OB_EX_ETC_HOSTS["$OB_OFS_NAME""${OB_ALPHA[i]}"]}"
	OB_HOST="$OB_OFS_NAME""${OB_ALPHA[i]}"
	for j in `seq 1 $OB_OFS_PER_INSTANCE`
	do
		# deduce my whacky alias from the autogenned conf file.
		me=`grep "^	Alias " "$OB_OFS_CONFIG_FILE_NAME" | \
			grep $OB_HOST | \
			sed $j'q;d' | \
			awk '{ print $2 }'`
		# vague sanity check...
		if [ `grep Alias "$OB_OFS_CONFIG_FILE_NAME" | \
			grep "$me" | \
			wc -l` -ne "1" ]
		then
			echo -e "\nI don't know who I am :"$me":"
			ob_cleanup
		fi
		mount_point="$OB_MOUNT_POINT""${port[$j]}"
		datastorage=$mount_point/data
		metastorage=$mount_point/meta

		# change the DataStorageSpace and MetadataStorageSpace
		# designations to coincide with where we mounted the SSD
		# drives.
		escape_slashes=$(echo $datastorage | sed 's/\//\\\//g')
		sed -i 's/D.*'$OB_HOST'.*'${port[$j]}'/DataStorageSpace '$escape_slashes'/' orangefs.conf
		if [ "$?" -gt "0" ]
		then
			echo -e "\ncan't edit data storage :"$OB_HOST":"$j":"
			ob_cleanup
		fi
		escape_slashes=$(echo $metastorage | sed 's/\//\\\//g')
		sed -i 's/M.*'$OB_HOST'.*'${port[$j]}'/MetadataStorageSpace '$escape_slashes'/' orangefs.conf
		if [ "$?" -gt "0" ]
		then
			echo -e "\ncan't edit meta storage :"$OB_HOST":"$j":"
			ob_cleanup
		fi

		# copy over the config file.
		scp -o "StrictHostKeyChecking no" "$OB_OFS_CONFIG_FILE_NAME" \
			"$OB_EX_IP": > /dev/null 2>&1
		if [ "$?" -gt "0" ]
		then
			echo -e "\nscp ofs config to :"$OB_HOST": failed."
			ob_cleanup
		fi

		ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" sudo \
			pvfs2-server "$OB_OFS_CONFIG_FILE_NAME" -f \
				-a "$me" \
					> /dev/null 2>&1
		if [ "$?" -gt "0" ]
		then
			echo -e "\nstorage failed on :"$OB_HOST":"$j":"
			ob_cleanup
		fi

		ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" sudo \
			pvfs2-server "$OB_OFS_CONFIG_FILE_NAME" \
				-a "$me" \
					> /dev/null 2>&1
		if [ "$?" -gt "0" ]
		then
			echo -e "\nofs server on :"$OB_HOST":""$j"" failed."
			ob_cleanup
		fi
		echo -n "."
	done
done
echo " done."
echo

# check connectivity on io500 clients.
echo -n "Testing connectivity to port 22 on io500 servers. "
for i in `seq 1 $OB_IO500_CLIENTS`
do
	OB_TRYS=$OB_ATTEMPTS
	while [ "$OB_TRYS" -gt "0" ] && \
		! nc -z ${OB_EX_ETC_HOSTS["$OB_IO500_NAME""${OB_ALPHA[i]}"]} 22
	do
		sleep $OB_SLEEP
		OB_TRYS=$(( OB_TRYS - 1 ))
		if [ "$OB_TRYS" -eq "0" ]
		then
			echo -e "\nno response from " \
			"${OB_EX_ETC_HOSTS["$OB_IO500_NAME""${OB_ALPHA[i]}"]}" \
			"on port 22."
			ob_cleanup
		fi
	done
	echo -n "."
done
echo " done."

echo -n "add io500 client internal IP addrs to each clients's host file. "
for i in `seq 1 $OB_IO500_CLIENTS`
do
	OB_IN_IP="${OB_IN_ETC_HOSTS["$OB_IO500_NAME""${OB_ALPHA[i]}"]}"
	OB_HOST="$OB_IO500_NAME""${OB_ALPHA[i]}"
	echo "$OB_IN_IP"" ""$OB_HOST" >> hostfile
done
# append the local host file onto the end of all the io500 client host files.
for i in `seq 1 $OB_IO500_CLIENTS`
do
	OB_EX_IP="${OB_EX_ETC_HOSTS["$OB_IO500_NAME""${OB_ALPHA[i]}"]}"
	OB_HOST="$OB_IO500_NAME""${OB_ALPHA[i]}"
	scp -o "StrictHostKeyChecking no" \
		hostfile "$OB_EX_IP": > /dev/null 2>&1
	if [ "$?" -gt "0" ]
	then
		echo -e "\nscp host file to :"$OB_HOST": failed."
		ob_cleanup
	fi
	ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
		sudo sh -c \'cat hostfile \>\> /etc/hosts\' > /dev/null 2>&1
	if [ "$?" -gt "0" ]
	then
		echo -e "\nappend hostfile on :"$OB_HOST": failed."
		ob_cleanup
	fi
	echo -n "."
done
echo " done."

# "third party" ssh tools such as mpirun need to be usable
# on the clients without interaction from a human... set up
# passwordless ssh access between the client instances:
#  + generate a keypair for each client
#  + collect all the public keys
#  + fixup authorized_keys and known_hosts on each client
#
echo -n "create ssh key pairs for the clients"
for i in `seq 1 $OB_IO500_CLIENTS`
do
	OB_EX_IP="${OB_EX_ETC_HOSTS["$OB_IO500_NAME""${OB_ALPHA[i]}"]}"
	OB_HOST="$OB_IO500_NAME""${OB_ALPHA[i]}"
	ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
		ssh-keygen -b 2048 -t rsa -f .ssh/id_rsa -q -N \"\" \
			> /dev/null 2>&1
	if [ "$?" -gt "0" ]
	then
		echo -e "\nssh-keygen on :"$OB_HOST": failed."
		ob_cleanup
	fi

	ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
		cat .ssh/id_rsa.pub >> pub.keys 2> /dev/null
	if [ "$?" -gt "0" ]
	then
		echo -e "\nretrieve pub key from :"$OB_HOST": failed."
		ob_cleanup
	fi
done
for i in `seq 1 $OB_IO500_CLIENTS`
do
	OB_EX_IP="${OB_EX_ETC_HOSTS["$OB_IO500_NAME""${OB_ALPHA[i]}"]}"
	OB_HOST="$OB_IO500_NAME""${OB_ALPHA[i]}"
	cat pub.keys | \
		ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
			"cat >> .ssh/authorized_keys" 2> /dev/null
	if [ "$?" -gt "0" ]
	then
		echo -e "\n copy public keys to :"$OB_HOST": failed."
		ob_cleanup
	fi

	for j in `seq 1 $OB_IO500_CLIENTS`
	do
		jth_host="$OB_IO500_NAME""${OB_ALPHA[j]}"
		ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
			'ssh-keyscan -H '"$jth_host"' >> .ssh/known_hosts' \
				2> /dev/null
		if [ "$?" -gt "0" ]
		then
			echo -e "\n ssh-keyscan on :"$jth_host": failed."
			ob_cleanup
		fi
	done
	echo -n "."
done
echo " done."

echo -n "mount the orangefs filesystem on the io500 clients. "
for i in `seq 1 $OB_IO500_CLIENTS`
do
	OB_EX_IP="${OB_EX_ETC_HOSTS["$OB_IO500_NAME""${OB_ALPHA[i]}"]}"
	OB_HOST="$OB_IO500_NAME""${OB_ALPHA[i]}"

	# load the orangefs kernel module...
	ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
		sudo insmod /lib/modules/\`uname -r\`/kernel/fs/orangefs/orangefs.ko.xz > /dev/null 2>&1
	if [ "$?" -gt "0" ]
	then
		echo -e "\nload kernel module on :"$OB_HOST": failed."
		ob_cleanup
	fi
	
	# start the client
	ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
		sudo pvfs2-client -p /usr/sbin/pvfs2-client-core \
			> /dev/null 2>&1
	if [ "$?" -gt "0" ]
	then
		echo -e "\nstart client on :"$OB_HOST": failed."
		ob_cleanup
	fi

	# create /pvfsmnt
	ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
		sudo mkdir /pvfsmnt > /dev/null 2>&1
	if [ "$?" -gt "0" ]
	then
		echo -e "\nmkdir /pvfsmnt on :"$OB_HOST": failed."
		ob_cleanup
	fi

	# mount the filesystem. Notice what "$OB_OFS_NAME"a resolves to.
	ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
		sudo mount -t pvfs2 \
			tcp://"$OB_OFS_NAME"a:3334/orangefs /pvfsmnt \
				> /dev/null 2>&1
	if [ "$?" -gt "0" ]
	then
		echo -e "\nmount to /pvfsmnt on :"$OB_HOST": failed."
		ob_cleanup
	fi
	echo -n "."
done
echo " done."

# We used hostfile to extend /etc/hosts on all the instances
# with the names of all the orangefs servers and all the io500
# clients. Now we'll remove all the orangefs servers from hostfile
# and all of the client's IP addrs and use hostfile as a list
# of client names to run io500 on.
sed -i "/${OB_OFS_NAME}/d" hostfile
if [ "$?" -gt "0" ]
then
	echo "purge of servers in hostfile failed."
	ob_cleanup
fi
sed -i "s/^.* //" hostfile
if [ "$?" -gt "0" ]
then
	echo "purge of ip addrs in hostfile failed."
	ob_cleanup
fi
if [ "$OB_SLOTS" -gt "0" ]
then
	sed -i "s/$/ slots=$OB_SLOTS/" hostfile
	if [ "$?" -gt "0" ]
	then
		echo "adding slots to hostfile failed."
		ob_cleanup
	fi
fi

if [ "$OB_MPI_TYPE" = "openmpi" ]
then
	OB_MPI_REPO="/home/io500_openmpi"
elif [ "$OB_MPI_TYPE" = "intel" ]
then
	OB_MPI_REPO="/home/io500_intel"
else
	OB_MPI_REPO="/home/io500_vanilla"
fi

# If mpi type is set to openmpi, then we need to provide
# proper paths to the io500 clients in order to avoid the dreaded
# "orted: command not found"...
if [ "$OB_MPI_TYPE" = "openmpi" ]
then
	echo -n "add openmpi vars to .bashrc on io500 clients."
	for i in `seq 1 $OB_IO500_CLIENTS`
	do
		OB_EX_IP="${OB_EX_ETC_HOSTS["$OB_IO500_NAME""${OB_ALPHA[i]}"]}"
		OB_HOST="$OB_IO500_NAME""${OB_ALPHA[i]}"
		ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
			sudo gsutil cp "$OB_BUCKET"/openmpivars . \
				> /dev/null 2>&1
		if [ "$?" -gt "0" ]
		then
			echo "bucket cp openmpi path to :""$OB_HOST"": failed."
			ob_cleanup
		fi

		ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
			sudo sh -c \'cat openmpivars \>\> .bashrc\' \
				> /dev/null 2>&1
		if [ "$?" -gt "0" ]
		then
			echo -e "\nappend opempivars on :"$OB_HOST": failed."
			ob_cleanup
		fi
	echo -n "."
	done
	echo " done."
fi

# copy io500 configs over to the io500 clients.
echo -n "copy io500 configs to the io500 clients. "
for i in `seq 1 $OB_IO500_CLIENTS`
do
	OB_EX_IP="${OB_EX_ETC_HOSTS["$OB_IO500_NAME""${OB_ALPHA[i]}"]}"
	OB_HOST="$OB_IO500_NAME""${OB_ALPHA[i]}"
	ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
		gsutil cp "$OB_BUCKET"/config-custom.ini \
		   "$OB_IO500_CONFIG" > /dev/null 2>&1
	if [ "$?" -gt "0" ]
	then
		echo "bucket copy custom config to :""$OB_HOST"": failed."
		ob_cleanup
	fi
	ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
		gsutil cp "$OB_BUCKET"/io500.sh \
			"$OB_IO500_CONFIG" > /dev/null 2>&1
	if [ "$?" -gt "0" ]
	then
		echo "bucket copy io500.sh to :""$OB_HOST"": failed."
		ob_cleanup
	fi

	# copy client hostnames in hostfile to io500/hostfile.
	scp -o "StrictHostKeyChecking no" \
		hostfile "$OB_EX_IP":"$OB_IO500_CONFIG" > /dev/null 2>&1
	if [ "$?" -gt "0" ]
	then
		echo -e "\nscp client list file to :"$OB_HOST": failed."
		ob_cleanup
	fi
done
echo " done."

# run io500 on the "a" io500 client.
if [ "$OB_IO500_CLIENTS" -gt "0" ] && [ "$OB_RUN_IO500" -gt "0" ]
then
        OB_EX_IP="${OB_EX_ETC_HOSTS["$OB_IO500_NAME""a"]}"
        OB_HOST="$OB_IO500_NAME""a"

	# run io500.sh
	echo "start io500 on :""$OB_HOST"":."
	if [ "$OB_MPI_TYPE" = "intel" ]
	then
		  mpi_setup_script="/opt/intel/oneapi/setvars.sh"
	elif [ "$OB_MPI_TYPE" = "openmpi" ]
	then
		  mpi_setup_script="$OB_MPI_REPO"/setvars_openmpi.sh
	else
		  mpi_setup_script="$OB_MPI_REPO"/setvars_vanilla.sh
	fi

	ssh -o "StrictHostKeyChecking no" "$OB_EX_IP" \
	  '(. '"$mpi_setup_script"'; \
	     cd '"$OB_MPI_REPO"'/io500; \
		chmod 764 '"$OB_IO500_CONFIG"'/io500.sh; \
			'"$OB_IO500_CONFIG"'/io500.sh \
				'"$OB_IO500_CONFIG"'/config-custom.ini)' \
					> /dev/null 2>&1

	if [ "$?" -gt "0" ]
	then
		echo "io500 failed to run on :""$OB_HOST"":."
		ob_cleanup
	fi
else
	echo "everything should be set up, you'll have to run io500 manually"
fi

echo
ob_cleanup
